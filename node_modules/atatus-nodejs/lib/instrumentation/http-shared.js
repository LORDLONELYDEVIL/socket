'use strict'

var url = require('url')

var endOfStream = require('end-of-stream')
var utils = require('../utils')

const transactionForResponse = new WeakMap()
exports.transactionForResponse = transactionForResponse

exports.instrumentRequest = function (agent, moduleName) {
  var ins = agent._instrumentation
  var captureBody = agent._conf.captureBody

  return function (orig) {
    return function (event, req, res) {
      if (event === 'request') {
        agent.logger.debug('intercepted request event call to %s.Server.prototype.emit', moduleName)

        if (isRequestBlacklisted(agent, req)) {
          agent.logger.debug('ignoring blacklisted request to %s', req.url)
          // don't leak previous transaction
          agent._instrumentation.currentTransaction = null
        } else {
          var traceparent = req.headers['atatus-traceparent']
          var trans = agent.startTransaction(null, null, traceparent)
          trans.type = 'request'
          trans.req = req
          trans.res = res

          transactionForResponse.set(res, trans)

          ins.bindEmitter(req)
          ins.bindEmitter(res)

          var shouldCaptureBody = captureBody === 'response' || captureBody === 'all'

          // we only need to patch res.write if we are captureBody
          if (shouldCaptureBody) {
            var resBodyBuf
            var resBodyBufLimitedExceeded

            res._orig_write = res.write
            res.write = function (chunk, encoding, callback) {
              agent.logger.debug('response write append chunk : ' + chunk)

              try {
                if (
                  !resBodyBufLimitedExceeded &&
                  utils.totalChunkLength(resBodyBuf, chunk) < utils._MAX_HTTP_BODY_CHARS
                ) {
                  resBodyBuf = utils.appendChunk(resBodyBuf, chunk)
                } else {
                  resBodyBufLimitedExceeded = true
                  resBodyBuf = 'BODY_SIZE_EXCEEDED'
                }
              } catch (e) {
                agent.logger.debug('response write failed : ', e)
              }

              res._orig_write.apply(this, arguments)
            }

            res._orig_end = res.end
            res.end = function (chunk, encoding, callback) {

              var finalBuf = resBodyBuf

              try {
                if (chunk && typeof chunk !== 'function') {
                  agent.logger.debug('response end append chunk : ' + chunk)
                  if (
                    !resBodyBufLimitedExceeded &&
                    utils.totalChunkLength(resBodyBuf, chunk) < utils._MAX_HTTP_BODY_CHARS
                  ) {
                    finalBuf = utils.appendChunk(resBodyBuf, chunk)
                  } else {
                    finalBuf = 'BODY_SIZE_EXCEEDED'
                  }
                }
              } catch (e) {
                agent.logger.debug('response end failed : ', e)
              }

              const result = res._orig_end.apply(this, arguments)

              if (finalBuf && finalBuf.length) {
                  res._atbody = finalBuf
              }
              trans.end()
              return result
            }
          }

          endOfStream(res, function (err) {
            if (!err) return trans.end()

            if (agent._conf.errorOnAbortedRequests && !trans.ended) {
              var duration = trans._timer.elapsed()
              if (duration > (agent._conf.abortedErrorThreshold * 1000)) {
                agent.captureError('Socket closed with active HTTP request (>' + agent._conf.abortedErrorThreshold + ' sec)', {
                  request: req,
                  extra: { abortTime: duration }
                })
              }
            }

            if (!shouldCaptureBody) {
              // Handle case where res.end is called after an error occurred on the
              // stream (e.g. if the underlying socket was prematurely closed)
              const end = res.end
              res.end = function () {
                const result = end.apply(this, arguments)
                trans.end()
                return result
              }
            }
          })
        }
      }

      return orig.apply(this, arguments)
    }
  }
}

function isRequestBlacklisted (agent, req) {
  var i

  for (i = 0; i < agent._conf.ignoreUrlStr.length; i++) {
    if (agent._conf.ignoreUrlStr[i] === req.url) return true
  }
  for (i = 0; i < agent._conf.ignoreUrlRegExp.length; i++) {
    if (agent._conf.ignoreUrlRegExp[i].test(req.url)) return true
  }

  var ua = req.headers['user-agent']
  if (!ua) return false

  for (i = 0; i < agent._conf.ignoreUserAgentStr.length; i++) {
    if (ua.indexOf(agent._conf.ignoreUserAgentStr[i]) === 0) return true
  }
  for (i = 0; i < agent._conf.ignoreUserAgentRegExp.length; i++) {
    if (agent._conf.ignoreUserAgentRegExp[i].test(ua)) return true
  }

  return false
}

// NOTE: This will also stringify and parse URL instances
// to a format which can be mixed into the options object.
function ensureUrl (v) {
  if (typeof v === 'string') {
    return url.parse(v)
  } else if (v instanceof url.Url) {
    return v
  } else if (url.URL && v instanceof url.URL) { // check for url.URL because it wasn't added until Node.js 6.13.0
    return url.parse(v.toString())
  } else {
    return v
  }
}

function trackOutgoingRequest(agent, request, span) {
  var captureBody = agent._conf.captureBody
  var shouldCaptureRequestBody = captureBody === 'request' || captureBody === 'all'
  var shouldCaptureResponseBody = captureBody === 'response' || captureBody === 'all'
  var contentTypes =  agent._conf.logBodyContentTypes || []
  var isAllowedContentType = false

  // var finished = false
  var requestBody = null

  var originalRequestWrite = request.write
  request.write = function(chunk, encoding, callback) {
    var writeReturnValue = originalRequestWrite.call(request, chunk, encoding, callback)
    if (shouldCaptureRequestBody) {
      requestBody = utils.appendChunk(requestBody, chunk)
    }
    return writeReturnValue
  }

  var originalRequestEnd = request.end
  request.end = function(chunk, encoding, callback) {
    var endReturnValue = originalRequestEnd.call(request, chunk, encoding, callback)
    if (shouldCaptureRequestBody) {
      requestBody = utils.appendChunk(requestBody, chunk)
      requestBody = utils.getResponseBodyString(requestBody, false)
    }
    span.setHttpContext({
      request: { headers: request._headers, body: requestBody },
      method: request.method
    })
    return endReturnValue
  }

  request.on("response", function (res) {
    var responseBody = null

    // Check allowed content type
    for (let i = 0; i < contentTypes.length; i++) {
      isAllowedContentType = res.headers['content-type'] && res.headers['content-type'].includes(contentTypes[i])
      if (isAllowedContentType) {
        break
      }
    }

    if (agent._conf.analyticsOutgoingOnPatch) {
      // var myStream = res
      // var dataEventTracked = false
      // var endEventTracked = false
      // myStream._at_on = myStream.on

      // myStream.on = function (evt, handler) {
      //   var passOnHandler = handler
      //   if (evt === "data" && !dataEventTracked) {
      //     dataEventTracked = true
      //     passOnHandler = function (chs) {
      //       responseBody = utils.appendChunk(responseBody, chs)
      //       responseBody = utils.getResponseBodyString(responseBody, false)
      //       // always update end time in case end event is not triggered.
      //       return handler(chs)
      //     }
      //   } else if (evt === "end" && !endEventTracked) {
      //     endEventTracked = true
      //     passOnHandler = function (chs) {

      //       if (!finished) {
      //         finished = true
      //       }

      //       return handler(chs)
      //     }
      //   }
      //   return myStream._at_on(evt, passOnHandler)
      // }
    } else {

      // FIXME: Stripe API is breaking res.on('data', ) calls.
      // So we ignore the capturing of response body.
      if (request._headers && request._headers.host === 'api.stripe.com') {
        isAllowedContentType = false
      } else {
        res.on('data', function(d) {
          if (isAllowedContentType && shouldCaptureResponseBody) {
            responseBody = utils.appendChunk(responseBody, d)
          }
        })
      }

      // res.on('abort', function() {
      //   finished = true
      // })

      res.on('end', function() {
        // finished = true
        if (isAllowedContentType && shouldCaptureResponseBody) {
          var isCompresssed =  res.isCompressed || !!((res.headers && res.headers['content-encoding'] || '').length)
          responseBody = utils.getResponseBodyString(responseBody, isCompresssed)
        }
        span.setHttpContext({
          response: { body: responseBody },
          statusCode: res.statusCode
        })
      })
    }
  })

  // request.on('error', function(error) {
  //   finished = true
  // })

  // fail safe if not finished
  // setTimeout(() => {
  //   if (!finished) {
  //     finished = true
  //   }
  // }, agent._conf.analyticsOutgoingTimeout || 30000)
}

exports.traceOutgoingRequest = function (agent, moduleName, method) {
  var spanType = 'ext.' + moduleName + '.http'
  var ins = agent._instrumentation
  var analytics = agent._conf.analytics && !!(agent._conf.backendConfig && agent._conf.backendConfig.analytics)
  var analyticsCaptureOutgoing = agent._conf.analyticsCaptureOutgoing

  return function (orig) {
    return function (...args) {
      // TODO: See if we can delay the creation of span until the `response`
      // event is fired, while still having it have the correct stack trace
      var span = agent.startSpan(null, spanType)
      var id = span && span.transaction.id

      agent.logger.debug('intercepted call to %s.%s %o', moduleName, method, { id: id })

      var options = {}
      var newArgs = [ options ]
      for (let arg of args) {
        if (typeof arg === 'function') {
          newArgs.push(arg)
        } else {
          Object.assign(options, ensureUrl(arg))
        }
      }

      if (!options.headers) options.headers = {}

      // Attempt to use the span context as a traceparent header.
      // If the transaction is unsampled the span will not exist,
      // however a traceparent header must still be propagated
      // to indicate requested services should not be sampled.
      // Use the transaction context as the parent, in this case.
      var parent = span || agent.currentTransaction
      if (parent && parent._context && shouldPropagateTraceContext(options)) {
        options.headers['atatus-traceparent'] = parent._context.toString()
      }

      var req = orig.apply(this, newArgs)
      if (!span) return req

      var protocol = (req.agent && req.agent.protocol) || 'http:'
      var headerHost = utils.getSafeHost(req)
      if (agent._conf.serverHosts && agent._conf.serverHosts.indexOf(headerHost) !== -1) {
        agent.logger.debug('ignore %s request to intake API %o', moduleName, { id: id })
        return req
      } else {
        agent.logger.debug('request details: %o', { protocol: protocol, host: headerHost, id: id })
      }

      ins.bindEmitter(req)

      // span.name = req.method + ' ' + headerHost + url.parse(req.path).pathname
      span.name = headerHost
      span.setHttpContext({ url: protocol + '//' + headerHost + req.path })
      // span.setHttpContext({ url: req.method + ' ' + headerHost + req.path })

      // Capture external request separately in analytics
      if (analytics && analyticsCaptureOutgoing) {
        trackOutgoingRequest(agent, req, span)
      }

      // TODO: Research if it's possible to add this to the prototype instead.
      // Or if it's somehow preferable to listen for when a `response` listener
      // is added instead of when `response` is emitted.
      const emit = req.emit
      req.emit = function (type, res) {
        if (type === 'response') onresponse(res)
        return emit.apply(req, arguments)
      }

      return req

      function onresponse (res) {
        agent.logger.debug('intercepted http.ClientRequest response event %o', { id: id })
        ins.bindEmitter(res)

        if (analytics && analyticsCaptureOutgoing) {
          // The content encoding is not coming in any of the above response 'on' calls except this emit call
          res.isCompressed = !!((res.headers && res.headers['content-encoding'] || '').length)
          span.setHttpContext({
            responseHeaders: { ...res.headers }
          })
        }

        // Inspired by:
        // https://github.com/nodejs/node/blob/9623ce572a02632b7596452e079bba066db3a429/lib/events.js#L258-L274
        if (res.prependListener) {
          // Added in Node.js 6.0.0
          res.prependListener('end', onEnd)
        } else {
          var existing = res._events && res._events.end
          if (!existing) {
            res.on('end', onEnd)
          } else {
            if (typeof existing === 'function') {
              res._events.end = [onEnd, existing]
            } else {
              existing.unshift(onEnd)
            }
          }
        }

        function onEnd () {
          agent.logger.debug('intercepted http.IncomingMessage end event %o', { id: id })
          span.end()
        }
      }
    }
  }
}

function shouldPropagateTraceContext (opts) {
  return !isAWSSigned(opts)
}

function isAWSSigned (opts) {
  const auth = opts.headers && (opts.headers.Authorization || opts.headers.authorization)
  return typeof auth === 'string' ? auth.startsWith('AWS4-') : false
}
