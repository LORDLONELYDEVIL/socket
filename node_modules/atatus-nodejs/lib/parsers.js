'use strict'

var util = require('util')
var parseUrl = require('url').parse

var afterAll = require('after-all-results')
var basicAuth = require('basic-auth')
var getOriginalUrl = require('original-url')
var httpHeaders = require('http-headers')
var stringify = require('fast-safe-stringify')
var truncate = require('unicode-byte-truncate')
var utils = require('./utils')

var stackman = require('./stackman')

var mysqlErrorMsg = /(ER_[A-Z_]+): /

exports.parseMessage = function (msg) {
  var error = { log: {} }

  if (typeof msg === 'string') {
    error.log.message = msg
  } else if (typeof msg === 'object' && msg !== null) {
    // if `captureError` is passed an object instead of an error or a string we
    // expect it to be in the format of `{ message: '...', params: [] }` and it
    // will be used as `param_message`.
    if (msg.message) {
      error.log.message = util.format.apply(this, [msg.message].concat(msg.params))
      error.log.param_message = msg.message
    } else {
      error.log.message = util.inspect(msg)
    }
  } else {
    error.log.message = String(msg)
  }

  return error
}

exports.parseError = function (err, agent, cb) {
  stackman.callsites(err, function (_err, callsites) {
    if (_err) {
      agent.logger.debug('error while getting error callsites: %s', _err.message)
    }

    var errorMsg = String(err.message)
    var error = {
      exception: {
        message: errorMsg,
        type: String(err.name)
      }
    }

    if ('code' in err) {
      error.exception.code = String(err.code)
    } else {
      // To provide better grouping of mysql errors that happens after the async
      // boundery, we modify to exception type to include the custom mysql error
      // type (e.g. ER_PARSE_ERROR)
      var match = errorMsg.match(mysqlErrorMsg)
      if (match) error.exception.code = match[1]
    }

    var props = stackman.properties(err)
    if (props.code) delete props.code // we already have it directly on the exception
    if (Object.keys(props).length > 0) error.exception.attributes = props

    var next = afterAll(function (_, frames) {
      // As of now, parseCallsite suppresses errors internally, but even if
      // they were passed on, we would want to suppress them here anyway

      if (frames) {
        var culprit = getCulprit(frames)
        var module = getModule(frames)
        if (culprit) error.culprit = culprit // TODO: consider moving culprit to exception
        if (module) error.exception.module = module // TODO: consider if we should include this as it's not originally what module was intended for
        error.exception.stacktrace = frames
      }

      cb(null, error)
    })

    if (callsites) {
      callsites.forEach(function (callsite) {
        exports.parseCallsite(callsite, true, agent, next())
      })
    }
  })
}

exports.getContextFromRequest = function (req, conf) {
  var captureBody = conf.captureBody === 'request' || conf.captureBody === 'all'

  var context = {
    http_version: req.httpVersion,
    method: req.method,
    url: getUrlFromRequest(req),
    socket: {
      remote_address: req.socket.remoteAddress,
      encrypted: !!req.socket.encrypted
    },
    headers: undefined
  }

  if (conf.captureHeaders) {
    context.headers = Object.assign({}, req.headers)
  }

  var contentLength = parseInt(req.headers['content-length'], 10)
  var transferEncoding = req.headers['transfer-encoding']
  var chunked = typeof transferEncoding === 'string' && transferEncoding.toLowerCase() === 'chunked'
  var body = req.json || req.body || req.payload
  var haveBody = body && (chunked || contentLength > 0)

  if (haveBody) {
    if (captureBody) {
      context.body = exports.getBodyStr(body)
    } else {
      context.body = '[REDACTED]'
    }
  }

  // TODO: Tempoary fix for https://github.com/elastic/apm-agent-nodejs/issues/813
  if (context.url && context.url.port) {
    context.url.port = String(context.url.port)
  }

  return context
}

exports.getContextFromResponse = function (res, conf) {
  var captureBody = conf.captureBody === 'response' || conf.captureBody === 'all'
  var contentTypes = conf.logBodyContentTypes || []
  var isAllowedContentType = false

  var context = {
    status_code: res.statusCode,
    headers: undefined
  }

  if (conf.captureHeaders) {
    context.headers = res.headers || utils.getResponseHeaders(res) || {}
    for (let i = 0; i < contentTypes.length; i++) {
      isAllowedContentType = context.headers['content-type'] && context.headers['content-type'].includes(contentTypes[i])
      if (isAllowedContentType) {
        break
      }
    }
  }

  // if (type === 'errors') {
  //   context.headers_sent = res.headersSent
  //   context.finished = res.finished
  // }

  if (!isAllowedContentType) {
    return context
  }

  if (res._atbody) {
    if (captureBody) {
      var isCompresssed = !!((context.headers['content-encoding'] || '').length)
      context.body = utils.getResponseBodyString(res._atbody, isCompresssed)
    } else {
      context.body = '[REDACTED]'
    }
  }

  return context
}

exports.getUserContextFromRequest = function (req) {
  var user = req.user || basicAuth(req) || req.session
  if (!user) return

  var context = {}

  if (typeof user.authenticated === 'boolean') {
    context.is_authenticated = user.authenticated
  }

  var user_id = user.id || user._id || user.user_id || user.userId
  if (typeof user_id === 'string' || typeof user_id === 'number') {
    context.id = '' + user_id
  }

  if (typeof user.username === 'string') {
    context.name = user.username
  } else if (typeof user.name === 'string') {
    context.name = user.name
  } else if (typeof user.firstName === 'string') {
    context.name = user.firstName
    if (typeof user.lastName === 'string') {
      context.name = user.firstName + ' ' + user.lastName
    }
  }

  if (typeof user.email === 'string') {
    context.email = user.email
  }

  return context
}

exports.parseCallsite = function (callsite, isError, agent, cb) {
  var conf = agent._conf
  var filename = callsite.getFileName()
  var frame = {
    filename: callsite.getRelativeFileName() || '',
    lineno: callsite.getLineNumber(),
    function: callsite.getFunctionNameSanitized(),
    library_frame: !callsite.isApp()
  }
  if (!Number.isFinite(frame.lineno)) frame.lineno = 0 // this should be an int, but sometimes it's not?! ¯\_(ツ)_/¯
  if (filename) frame.abs_path = filename

  var lines = isError
    ? (callsite.isApp() ? conf.sourceLinesErrorAppFrames : conf.sourceLinesErrorLibraryFrames)
    : (callsite.isApp() ? conf.sourceLinesSpanAppFrames : conf.sourceLinesSpanLibraryFrames)

  if (lines === 0 || callsite.isNode()) {
    setImmediate(cb, null, frame)
    return
  }

  callsite.sourceContext(lines, function (err, context) {
    if (err) {
      agent.logger.debug('error while getting callsite source context: %s', err.message)
    } else {
      frame.pre_context = context.pre
      frame.context_line = context.line
      frame.post_context = context.post
    }

    cb(null, frame)
  })
}

exports.getBodyStr = function (body) {
  var bodyStr = typeof body === 'string'
    ? body
    : (tryJsonStringify(body) || stringify(body))
  if (bodyStr.length > utils._MAX_HTTP_BODY_CHARS) {
    bodyStr = truncate(bodyStr, utils._MAX_HTTP_BODY_CHARS)
  }
  return bodyStr
}

// Default `culprit` to the top of the stack or the highest non `library_frame`
// frame if such exists
function getCulprit (frames) {
  if (frames.length === 0) return

  var filename = frames[0].filename
  var fnName = frames[0].function
  for (var n = 0; n < frames.length; n++) {
    if (!frames[n].library_frame) {
      filename = frames[n].filename
      fnName = frames[n].function
      break
    }
  }

  return filename ? fnName + ' (' + filename + ')' : fnName
}

function getModule (frames) {
  if (frames.length === 0) return
  var frame = frames[0]
  if (!frame.library_frame) return
  var match = frame.filename.match(/node_modules\/([^/]*)/)
  if (!match) return
  return match[1]
}

function tryJsonStringify (obj) {
  try {
    return JSON.stringify(obj)
  } catch (e) {}
}

function safeGetReqSecure(req) {
  try {
    return req.secure
  } catch(err) {
    return false
  }
}

function safeGetHostname(req) {
  try {
    return req.hostname
  } catch(err) {
    return (req.headers && req.headers['x-forwarded-host']) || 'localhost'
  }
}

function getUrlFromRequest(req) {
  try {
    return getOriginalUrl(req)
  } catch (err) {
    try {
        const raw = req.originalUrl || req.url

        const protocol = (req.connection && req.connection.encrypted) || safeGetReqSecure(req) ? 'https:' : 'http:'
        const host = req.headers.host || safeGetHostname(req)
        const fullUrl = protocol + '//' + host + raw

        const parsedUrl = parseUrl(raw || '')

        var url = {
          raw: raw,
          protocol: protocol,
          hostname: host,
          port: parsedUrl.port ? Number(parsedUrl.port) : undefined,
          pathname: parsedUrl.pathname || raw,
          search: parsedUrl.search,
          full: fullUrl
        }

        return url
    } catch (e) {
        return null
    }
  }
}